## 목표
자바의 인터페이스에 대해 학습한다
## 학습할 것
- 인터페이스 정의하는 법
- 인터페이스 구현하는 법
- 인터페이스 레퍼런스를 통해 구현체를 사용하는 방법
- 인터페이스 상속
- 인터페이스의 기본 메소드(default method), 자바 8
- 인터페이스의 static 메소드, 자바 8
- 인터페이스의 private 메소드, 자바 9

### 인터페이스의 특징
인터페이스의 모든 필드는 public static final 로 정의되고, static 과 default 메서드 이외의 모든 메서드는
public abstract 로 정의된다.
```java
interface A {
    int a = 3; // 컴파일시 public static final 이 삽입됨
    void abc(); // 컴파일시 public abstact 가 삽입됨
}
public class A {
    public static void main(String[] args) {
        System.out.println(A.a); // 3
        // A.a = 4; final 이기 때문에 불가능
    }
}
```
### 인터페이스 정의하는 법
```java
interface 인터페이스명 {
    public static final 자료형 필드명 = 값;
    public abstract 리턴타입 메서드명();
}
```

### 인터페이스의 상속
클래스가 클래스를 상속할 때 : `extends` 키워드 사용 </br>
클래스가 인터페이스를 상속할 때 : `implements` 키워드 사용

인터페이스는 다중상속이 가능하다. 클래스에서 다중상속을 할 수 없었던 이유는 부모 클래스에 동일한 이름의 필드 또는 메서드가
존재할 경우, 모호성 때문에 충돌이 발생하기 때문이다. 하지만 인터페이스의 경우 필드는 static final 의 특성을 가지고 있기 때문에
각 인터페이스 내부에 존재하여 공간상 겹치지 않는다. 또한 메서드도 미완성이기 때문에, 자식 클래스에서 완성해 사용하므로 문제될 것이 없다.

클래스와 인터페이스를 동시에 상속할 수도 있는데, 순서가 반드시 extends 한 다음 implements 해야 한다.

인터페이스가 인터페이스를 상속할 때는 extends 키워드를 사용한다.

### 인터페이스의 기본 메소드(default method), 자바 8
default method 가 등장하기 전, 즉 자바 8 이전에는 과거의 자식 클래스들을 재사용하기 위해 인터페이스를 새롭게 정의해
사용할 수밖에 없었다. 이 문제점을 해결하기 위해 등장한 것이 디폴트메서드로, 인터페이스 내부에 완성된 메서드를 삽입하는 것이다.
디폴트 메서드는 이미 완성된 메서드이므로, 자식 클래스는 반드시 이 메서드를 오버라이딩하지 않아도 된다.

> 자식 클래스에 부모 인터페이스의 디폴트 메서드 호출 방법 ?

```java
interface A {
    default void abc() {
        System.out.print("A 인터페이스의 abc() ");
    }
}

class B implements A {
    @Override
    public void abc() {
        A.super.abc();
        System.out.print("B 클래스의 abc()");
    }

    public static void main(String[] args) {
        B b = new B();
        b.abc(); // A 인터페이스의 abc() B 클래스의 abc()
        
    }
}

```

 > 부모인터페이스명.super.디폴트메서드명
> 

그냥 super.abc() 를 사용한다면 상위클래스인 Object 클래스 내부에서 abc 메서드를 찾음

인터페이스는 다중상속이 되므로 어떤 부모 인터페이스 내부의 메서드를 호출하라는 소리인지 구분할 필요가 있다.
그래서 인터페이스 내의 메서드를 호출할 때는 '부모인터페이스명.super.부모메서드명' 처럼 호출하는 것이다.

### 인터페이스의 static 메소드, 자바 8
자바 8 이후부터 추가된 인터페이스의 두번째 기능은 static 메서드를 포함할 수 있다는 것이다. 객체를 생성하지 않고
'인터페이스명.정적메서드명()' 으로 바로 호출할 수 있다.

### 인터페이스의 private 메소드, 자바 9
인터페이스 내에서만 사용가능한 메서드이고 디폴트 메서드나 정적메서드에 사용하기 위해 작성되는 메서드.
인터페이스를 구현하는 클래스쪽에서 재정의하거나 사용할 수 없고 디폴트나 정적메서드를 통해서만 사용 가능.

### 인터페이스 레퍼런스를 통해 구현체를 사용하는 방법
동일한 인터페이스를 구현한 여러 클래스가 있다고 하자. new 키워드로 클래스를 생성하여 변수에 값을 할당할 때, 변수의 타입으로
생성한 클래스의 타입을 지정하는 것이 아닌 인터페이스의 타입으로 생성한 클래스의 타입을 지정해주는 것이다.

해당 인터페이스를 구현한 클래스라면, 인터페이스에 명세된 기능들이 모두 구현되어있다. 구체 클래스로 참조타입을 지정해주는 것보다,
인터페이스 타입으로 참조타입을 지정해주는 것을 지향하는 것이 좋다.


자바에서 s 가 들어가는 클래스들에는 각종 static 메서드들이 모여있음. 예로, Collections 클래스.

